% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recruit_method.R
\name{.recruit_next}
\alias{.recruit_next}
\title{Based on the candidate cells, recruit a specific cell}
\usage{
.recruit_next(
  mat_x,
  mat_y,
  vec_cand,
  res_g,
  df_res,
  dim_reduc_obj,
  nn_g,
  nn_mat,
  nn_obj,
  enforce_matched,
  df_cell,
  rec_options
)
}
\arguments{
\item{mat_x}{full data for Modality 1, where each row is a cell and each column is a variable}

\item{mat_y}{full data for Modality 2, where each row is a cell and each column is a variable}

\item{vec_cand}{output of \code{.candidate_set}}

\item{res_g}{output of \code{.estimate_g}}

\item{df_res}{data frame recording the current results, generated within \code{chromatin_potential}}

\item{dim_reduc_obj}{object to compute the dimension reduction for a given vector,
computed by \code{chromatin_potential_prepare}}

\item{nn_g}{nearest neighbor graph, represented as an \code{igraph} object}

\item{nn_mat}{the nearest-neighbor matrix, output from \code{chromatin_potential_prepare}}

\item{nn_obj}{the exposed C++ \code{RcppAnnoy} that encodes the nearest neighbor
information for the \code{n} cells}

\item{enforce_matched}{boolean, where if \code{TRUE}, recruited cells are matched
to only cells that previously-recruited}

\item{rec_options}{one of the outputs from \code{.chrom_options}}
}
\value{
a list of two things: a list called \code{rec} that contains
a  vector of integers \code{vec_from} and a list
of integers \code{list_to}, and a list called \code{diagnostic} that 
contains optionally-computed diagnostics to better-understand the recruitment
}
\description{
Here, \code{mat_x} are all the cells in our dataset, among which
we are saying that \code{vec_matched} are cells that have previously been
recruited already, and \code{vec_cand} are the currently-selected
candidates that we are hoping to recruit and match to one of the
previously-recruited cells acccording to \code{df_res}. This 
matching is done by using our estimation function \code{res_g}
on the candidate cell's Modality 1 expression in \code{mat_x}
and seeing if it's close to any prreviously-recruited cells's Modality 2 expressions
in \code{mat_y}.
}
\details{
The options are:
\itemize{
\item \code{nn}: Recruit \code{rec_options$num_rec} cells
whose combined Modality 1 and predicted Modality 2 expression
vector has the smallest average 
(for example, mean, or in general, depending on what \code{rec_options$average}
is set to) distance to its \code{rec_options$nn} 
nearest neighbors (based on \code{nn_obj})
\item \code{distant_cor}: Recruit all the cells in \code{vec_cand}
and match cell \code{i} to a supposed cell \code{j}
(and its \code{rec_options$nn} nearest-neighbors)
whose Modality 2 difference between cell \code{j} and \code{i} 
has the highest correlation (via \code{rec_optiosn$cor_method})
with the cell \code{i}'s change in Modality 2 (computed via \code{res_g}),
searching among the \code{rec_otions$inflation*ncol(nn_mat)}
nearest-neighbors of the combined Modality 1 and predicted Modality 2 expression
vector but excluding the nearest neighbors of cell \code{i}
(based on \code{nn_mat})
}
}
